#' Prepare Principal Change Factors Data
#' @param data List. Contents of the JSON generated by the inputs app.
#' @param sites Character. Location codes selected by the user from the outputs
#'     app interface.
#' @param mitigators Data.frame. A lookup from mitgator codes to huamn-readable
#'     names. Derived from the internal mitigators.json file.
#' @param at Character. The activity type (e.g. 'ip' for inpatients).
#' @param pods Character. The point of delivery (e.g.
#'     'ip_non-elective_admission').
#' @details This data will be used in the waterfall chart.
#' @noRd
prep_principal_change_factors <- function(
  data,
  sites,
  mitigators,
  at,
  pods
) {
  principal_change_factors_raw <- data |>
    get_principal_change_factors(at, sites)

  # if a site is selected then there are no rows for A&E
  if (nrow(principal_change_factors_raw) == 0) {
    stop("No data")
  }

  principal_change_factors_raw |>
    dplyr::mutate(
      dplyr::across("change_factor", forcats::fct_inorder),
      dplyr::across(
        "change_factor",
        \(.x) {
          forcats::fct_relevel(
            .x,
            "baseline",
            "demographic_adjustment",
            "health_status_adjustment"
          )
        }
      )
    ) |>
    dplyr::left_join(
      mitigators,
      by = dplyr::join_by("strategy")
    ) |>
    tidyr::replace_na(list("mitigator_name" = "-")) |>
    dplyr::filter(.data[["pod"]] %in% pods) |>
    dplyr::select(-"pod") |>
    dplyr::count(
      dplyr::across(-"value"),
      wt = .data[["value"]],
      name = "value"
    )
}

#' Prepare Individual Change Factors Data
#' @param principal_change_factors Data.frame. Prepared data for prinicpal
#'     change factors, derived using [prep_principal_change_factors].
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @details Used by [plot_individual_change_factors].
#' @noRd
prep_individual_change_factors <- function(
  principal_change_factors,
  measure
) {
  principal_change_factors |>
    dplyr::filter(
      .data$measure == .env$measure,
      .data$strategy != "-",
      .data$value < 0
    ) |>
    dplyr::mutate(
      dplyr::across(
        "mitigator_name",
        \(.x) forcats::fct_reorder(.x, -.data$value)
      )
    )
}

#' Plot Individual Change Factors Data
#' @param principal_change_factors Data.frame. Prepared data for principal
#'     change factors, derived using [prep_principal_change_factors].
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @param change_factor Character. The change factor grouping (e.g.
#'     activity_avoidance').
#' @details Used by [plot_impact_and_individual_change].
#' @noRd
plot_individual_change_factors <- function(
  principal_change_factors,
  measure,
  change_factor
) {
  individual_change_factors <-
    prep_individual_change_factors(principal_change_factors, measure) |>
    dplyr::filter(change_factor == .env$change_factor)

  mod_principal_change_factor_effects_ind_plot(
    individual_change_factors,
    change_factor,
    "#f9bf07",
    snakecase::to_title_case(change_factor),
    snakecase::to_title_case(measure)
  )
}

#' Plot Impact and Individual Change Factors Data
#' @param principal_change_factors Data.frame. Prepared data for principal
#'     change factors, derived using [prep_principal_change_factors].
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @details This creates the waterfall chart and the individual change factor
#'     charts (activity avoidance and efficiencies) as one object.
#' @noRd
plot_impact_and_individual_change <- function(
  principal_change_factors,
  measure
) {
  # nolint start: object_length_linter
  possibly_mod_principal_change_factor_effects_cf_plot <-
    purrr::possibly(
      mod_principal_change_factor_effects_cf_plot,
      "Insufficient information to produce this chart"
    )
  # nolint end

  possibly_plot_individual_change_factors <-
    purrr::possibly(
      plot_individual_change_factors,
      "Insufficient information to produce this chart"
    )

  waterfall_plot <- principal_change_factors |>
    mod_principal_change_factor_effects_summarised(measure, TRUE) |>
    possibly_mod_principal_change_factor_effects_cf_plot()

  activity_avoidance_plot <- principal_change_factors |>
    possibly_plot_individual_change_factors(measure, "activity_avoidance")

  efficiencies_plot <- principal_change_factors |>
    possibly_plot_individual_change_factors(measure, "efficiencies")

  dplyr::lst(waterfall_plot, activity_avoidance_plot, efficiencies_plot)
}

# Activity in detail ----

#' Generate Activity in Detail Table
#' @param data List. Contents of the JSON generated by the inputs app.
#' @param sites Character. Location codes selected by the user from the outputs
#'     app interface.
#' @param tretspefs Data.frame. Treatment specialties lookup of codes to
#'     descriptions. Derived from internal JSON lookup.
#' @param activity_type Character. The activity type (e.g. 'ip' for inpatients).
#' @param pod Character. The point of delivery (e.g.
#'     'ip_non-elective_admission').
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @param agg_col Character. Name of column to aggregate by (i.e. age,
#'     'age_group', or treatment specialty, 'tretspef').
#' @noRd
generate_activity_in_detail_table <- function(
  data,
  sites,
  tretspefs,
  activity_type,
  pod,
  measure,
  agg_col
) {
  aggregated_data <- data |>
    get_aggregation(pod, measure, agg_col, sites)

  # if a site is selected then there are no rows for A&E
  if (nrow(aggregated_data) == 0) {
    stop("No data")
  }

  aggregated_data <- aggregated_data |>
    dplyr::transmute(
      .data$sex,
      agg = .data[[agg_col]],
      .data$baseline,
      final = .data$principal,
      change = .data$final - .data$baseline,
      change_pcnt = .data$change / .data$baseline
    )

  if (agg_col == "tretspef") {
    aggregated_data <- aggregated_data |>
      dplyr::left_join(
        tretspefs,
        by = dplyr::join_by("agg" == "Code")
      ) |>
      dplyr::mutate(
        dplyr::across(
          "Description",
          \(x) dplyr::if_else(is.na(x), .data$agg, .data$Description)
        ),
      ) |>
      dplyr::select("sex", "Description", dplyr::everything(), -"agg") |>
      dplyr::rename("agg" = "Description")
  }

  end_year <- data[["params"]][["end_year"]]
  end_fyear <- paste0(
    end_year,
    "/",
    as.numeric(stringr::str_extract(end_year, "\\d{2}$")) + 1
  )

  aggregated_data |>
    mod_principal_detailed_table(
      aggregation = agg_col,
      final_year = end_fyear
    ) |>
    gt::tab_options(table.align = "left")
}

# Activity distribution----

#' Plot Activity Distribution Charts (Beeswarm and S-curve)
#' @param data List. Contents of the JSON generated by the inputs app.
#' @param sites Character. Location codes selected by the user from the outputs
#'     app interface.
#' @param activity_type Character. The activity type (e.g. 'ip' for inpatients).
#' @param pod Character. The point of delivery (e.g.
#'     'ip_non-elective_admission').
#' @param measure Character. A selected measure (e.g. 'beddays').
#' @noRd
plot_activity_distributions <- function(
  data,
  sites,
  activity_type,
  pod,
  measure
) {
  selected_measure <- c(activity_type, pod, measure)

  aggregated_data <- data |>
    mod_model_results_distribution_get_data(selected_measure, sites) # |>
  # require_rows()

  beeswarm_plot <- mod_model_results_distribution_beeswarm_plot(
    aggregated_data,
    show_origin = FALSE
  )

  ecdf_plot <- mod_model_results_distribution_ecdf_plot(
    aggregated_data,
    show_origin = FALSE
  )

  dplyr::lst(beeswarm_plot, ecdf_plot)
}


model_results_distribution_get_data <- function(
  r,
  selected_measure,
  sites
) {
  activity_type <- pod <- measure <- NULL
  c(activity_type, pod, measure) %<-% selected_measure
  get_model_run_distribution(r, pod, measure, sites)
}

mod_model_results_distribution_beeswarm_plot <- function(data, show_origin) {
  b <- data$baseline[[1]]
  p <- data$principal[[1]]

  variant_lookup <- get_golem_config("population_projections")[["values"]] |>
    unlist() |>
    tibble::enframe(name = "variant", value = "Population-projection variant")

  x_placeholder <- "100%" # dummy label to help line up beeswarm and ECDF plots

  data |>
    require_rows() |>
    dplyr::left_join(variant_lookup, "variant") |>
    ggplot2::ggplot() +
    suppressWarnings(
      ggbeeswarm::geom_quasirandom(
        ggplot2::aes(
          x = x_placeholder,
          y = .data$value,
          colour = .data$`Population-projection variant`,
          text = glue::glue(
            "Value: {scales::comma(value, accuracy = 1)}\nVariant: {`Population-projection variant`}"
          )
        ),
        alpha = 0.5
      )
    ) +
    ggplot2::geom_hline(yintercept = b, colour = "dimgrey") +
    ggplot2::geom_hline(yintercept = p, linetype = "dashed", colour = "red") +
    ggplot2::expand_limits(y = ifelse(show_origin, 0, b)) +
    ggplot2::coord_flip() +
    ggplot2::scale_y_continuous(
      breaks = scales::pretty_breaks(10),
      labels = scales::comma,
      expand = c(0.002, 0)
    ) +
    ggplot2::theme(
      legend.position = "bottom",
      axis.title.x = ggplot2::element_blank(),
      axis.ticks.y = ggplot2::element_blank(),
      # keep y-axis labels to help line up beeswarm/ECDF, but make 'invisible'
      axis.text.y = ggplot2::element_text(colour = "white"),
      axis.title.y = ggplot2::element_text(colour = "white")
    )
}


model_results_distribution_ecdf_plot <- function(data, show_origin) {
  b <- data$baseline[[1]]
  p <- data$principal[[1]]

  ecdf_fn <- stats::ecdf(data[["value"]])

  # Calculate x values for y-axis quantiles
  probs_pcnts <- c(0.1, 0.9)
  x_quantiles <- stats::quantile(ecdf_fn, probs = probs_pcnts)

  # Calculate y value for principal x value (find nearest % for the principal)
  x_vals <- sort(data[["value"]])
  y_vals <- sort(ecdf_fn(data[["value"]]))
  principal_diffs <- abs(p - x_vals) # nearest x in ECDF to the principal
  min_principal_diff_i <- which(principal_diffs == min(principal_diffs))[1]
  p_pcnt <- y_vals[min_principal_diff_i]

  min_x <- min(b, min(data[["value"]]))
  min_x <- dplyr::if_else(show_origin, 0, min_x)

  line_guides <- tibble::tibble(
    x_start = c(rep(min_x, 3), x_quantiles, p),
    x_end = rep(c(x_quantiles, p), 2),
    y_start = c(probs_pcnts, p_pcnt, rep(0, 3)),
    y_end = rep(c(probs_pcnts, p_pcnt), 2),
    colour = "cornflowerblue"
  )

  lines_n <- nrow(line_guides)
  line_guides[c(lines_n, lines_n / 2), "colour"] <- "red"

  data |>
    require_rows() |>
    ggplot2::ggplot() +
    suppressWarnings(
      ggplot2::geom_point(
        ggplot2::aes(
          x_vals,
          y_vals,
          text = glue::glue(
            "Percentage: {scales::percent(y_vals, accuracy = 1)}\n",
            "Value: {scales::comma(x_vals, accuracy = 1)}"
          )
        ),
        alpha = 0.01,
        size = 0.01
      )
    ) +
    ggplot2::geom_step(ggplot2::aes(x_vals, y_vals)) +
    ggplot2::geom_segment(
      ggplot2::aes(
        x = .data$x_start,
        y = .data$y_start,
        xend = .data$x_end,
        yend = .data$y_end
      ),
      data = line_guides,
      linetype = "dashed",
      colour = line_guides[["colour"]]
    ) +
    ggplot2::geom_vline(xintercept = b, colour = "dimgrey") +
    ggplot2::ylab("Percentage of model runs") +
    ggplot2::expand_limits(x = ifelse(show_origin, 0, b)) +
    ggplot2::scale_x_continuous(
      breaks = scales::pretty_breaks(10),
      labels = scales::comma,
      expand = c(0.002, 0),
      limits = c(min_x, NA)
    ) +
    ggplot2::scale_y_continuous(
      breaks = c(seq(0, 1, 0.1)),
      labels = scales::percent,
      expand = c(0, 0)
    ) +
    ggplot2::theme(axis.title.x = ggplot2::element_blank())
}
